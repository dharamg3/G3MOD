/*
 * HDC1100 LCD Panel Driver for the Samsung Universal board
 *
 * Author: Kyuhyeok Jang  <kyuhyeok.jang@samsung.com>
 *
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

#include <linux/wait.h>
#include <linux/fb.h>
#include <linux/delay.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>
#include <linux/spi/spi.h>
#include <mach/hardware.h>
#include <plat/gpio-cfg.h>
#include <linux/leds.h>
#include <linux/i2c/max8998.h>
#include <plat/regs-fb.h>
#include "s3cfb.h"

extern int apollo_get_saved_lcd_id_value();
extern int lcd_pm_state;
extern int s3cfb_force_resume();

static int s6d04d1_set_brightness(int level);
static int s6d04d1_init(void);

static int lcd_power = ON;
static int backlight_power = OFF;
static int backlight_level = 0x63;

#define S3C_FB_HRES             240     /* Horizon pixel Resolition */
#define S3C_FB_VRES             400     /* Vertical pixel Resolution */

#define S3C_FB_VFRAME_FREQ      85      /* Frame Rate Frequency */

/* FIXME: will be moved to platform data */
static struct s3cfb_lcd s6d04d1 = {
	.width = S3C_FB_HRES,
	.height = S3C_FB_VRES,
	.p_width = 42,
	.p_height = 70,
	.bpp = 16,
	.freq = S3C_FB_VFRAME_FREQ,
	.timing = {
		.h_fp = 8,
		.h_bp = 24,
		.h_sw = 12,
		.v_fp = 8,
		.v_fpe = 1,
		.v_bp = 8,
		.v_bpe = 1,
		.v_sw = 2,
        },
        .polarity = {
                .rise_vclk = 0,
                .inv_hsync = 0,
                .inv_vsync = 0,
                .inv_vden = 0,
        },
};



void s3cfb_set_lcd_info(struct s3cfb_global *ctrl)
{
	s6d04d1.init_ldi = NULL;
	ctrl->lcd = &s6d04d1;
}

/*
 * Serial Interface
 */

#define LCD_CSX_HIGH	gpio_set_value(GPIO_DISPLAY_CS, GPIO_LEVEL_HIGH);
#define LCD_CSX_LOW		gpio_set_value(GPIO_DISPLAY_CS, GPIO_LEVEL_LOW);

#define LCD_SCL_HIGH	gpio_set_value(GPIO_DISPLAY_CLK, GPIO_LEVEL_HIGH);
#define LCD_SCL_LOW		gpio_set_value(GPIO_DISPLAY_CLK, GPIO_LEVEL_LOW);

#define LCD_SDI_HIGH	gpio_set_value(GPIO_DISPLAY_SI, GPIO_LEVEL_HIGH);
#define LCD_SDI_LOW		gpio_set_value(GPIO_DISPLAY_SI, GPIO_LEVEL_LOW);

#define LCD_SDO_DATA	gpio_get_value(GPIO_DISPLAY_SO)
#define DEFAULT_USLEEP	1

#define POWCTL			0xF3
#define VCMCTL			0xF4
#define SRCCTL			0xF5
#define SLPOUT			0x11
#define TEON			0x35
#define MADCTL			0x36
#define COLMOD			0x3A
#define DISCTL			0xF2
#define IFCTL			0xF6
#define GATECTL			0xFD
#define WRDISBV			0x51
#define WRCABCMB		0x5E
#define MIECTL1			0xCA
#define BCMODE			0xCB
#define MIECTL2			0xCC
#define MIECTL3			0xCD
#define RPGAMCTL		0xF7
#define RNGAMCTL		0xF8
#define GPGAMCTL		0xF9
#define GNGAMCTL		0xFA
#define BPGAMCTL		0xFB
#define BNGAMCTL		0xFC
#define CASET			0x2A
#define PASET			0x2B
#define RAMWR           0x2C
#define WRCTRLD			0x53
#define WRCABC			0x55
#define DISPON			0x29
#define DISPOFF			0x28
#define SLPIN			0x10
#define RDDIDIF			0x04		// 4 parameters
#define	RDID1			0xDA		// 2 parameters
#define	RDID2			0xDB		// 2 parameters
#define	RDID3			0xDC		// 2 parameters

struct setting_table {
	u8 command;	
	u8 parameters;
	u8 parameter[15];
	s32 wait;
};

#if (CONFIG_BOARD_REVISION == CONFIG_APOLLO_EMUL)
static struct setting_table power_on_setting_table_30[] = {
	{   POWCTL,  7, { 0x80, 0x00, 0x00, 0x02, 0x44, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   VCMCTL,  5, { 0x33, 0x33, 0x5a, 0x5a, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SRCCTL,  5, { 0x12, 0x00, 0x03, 0xF0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
	{   MADCTL,  1, { 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   COLMOD,  1, { 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  30 },	
	{   DISCTL, 11, { 0x15, 0x15, 0x03, 0x08, 0x08, 0x08, 0x08, 0x10, 0x04, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  GATECTL,  2, { 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  WRDISBV,  1, { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 }, //BRIGHTNESS	
	{ WRCABCMB,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  MIECTL1,  3, { 0x80, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   BCMODE,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL2,  3, { 0x20, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
//	{  MIECTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL3,  2, { 0x2C, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{ RPGAMCTL, 15, { 0x00, 0x25, 0x2F, 0x1B, 0x21, 0x27, 0x2C, 0x35, 0x09, 0x0E, 0x19, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{ RNGAMCTL, 15, { 0x25, 0x00, 0x2F, 0x1B, 0x21, 0x27, 0x2C, 0x35, 0x09, 0x0E, 0x19, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{ GPGAMCTL, 15, { 0x00, 0x25, 0x0A, 0x24, 0x21, 0x27, 0x2C, 0x34, 0x0B, 0x08, 0x17, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{ GNGAMCTL, 15, { 0x25, 0x00, 0x0A, 0x24, 0x21, 0x27, 0x2C, 0x34, 0x0B, 0x08, 0x17, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{ BPGAMCTL, 15, { 0x00, 0x23, 0x2A, 0x09, 0x23, 0x25, 0x27, 0x2C, 0x16, 0x1A, 0x3D, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{ BNGAMCTL, 15, { 0x23, 0x00, 0x2A, 0x09, 0x23, 0x25, 0x27, 0x2C, 0x16, 0x1A, 0x3D, 0x15, 0x15, 0x22, 0x22 },   0 },	
	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  WRCTRLD,  1, { 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
};

static struct setting_table power_on_setting_table_32[] = {
	{   POWCTL,  7, { 0x80, 0x00, 0x00, 0x0B, 0x33, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   VCMCTL,  5, { 0x6E, 0x6E, 0x7F, 0x7F, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SRCCTL,  5, { 0x12, 0x00, 0x03, 0xF0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
	{   MADCTL,  1, { 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   COLMOD,  1, { 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  30 },	
	{   DISCTL, 11, { 0x14, 0x14, 0x03, 0x03, 0x04, 0x03, 0x04, 0x10, 0x04, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  GATECTL,  2, { 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  WRDISBV,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 }, //BRIGHTNESS	
	{ WRCABCMB,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  MIECTL1,  3, { 0x80, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   BCMODE,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL2,  3, { 0x20, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
//	{  MIECTL3,  2, { 0x2C, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{ RPGAMCTL, 15, { 0x00, 0x23, 0x15, 0x15, 0x1C, 0x1D, 0x1D, 0x21, 0x22, 0x28, 0x2C, 0x2C, 0x2C, 0x22, 0x21 },   0 },	
	{ RNGAMCTL, 15, { 0x19, 0x00, 0x15, 0x15, 0x1C, 0x1D, 0x1D, 0x21, 0x22, 0x28, 0x2C, 0x2C, 0x2C, 0x22, 0x21 },   0 },	
	{ GPGAMCTL, 15, { 0x00, 0x23, 0x15, 0x15, 0x1C, 0x1C, 0x1B, 0x1F, 0x24, 0x28, 0x2C, 0x2C, 0x2C, 0x22, 0x21 },   0 },	
	{ GNGAMCTL, 15, { 0x19, 0x00, 0x15, 0x15, 0x1C, 0x1C, 0x1B, 0x1F, 0x24, 0x28, 0x2C, 0x2C, 0x2C, 0x22, 0x21 },   0 },	
	{ BPGAMCTL, 15, { 0x00, 0x23, 0x15, 0x15, 0x1A, 0x18, 0x15, 0x17, 0x2E, 0x37, 0x3F, 0x3F, 0x3F, 0x22, 0x21 },   0 },	
	{ BNGAMCTL, 15, { 0x19, 0x00, 0x15, 0x15, 0x1A, 0x18, 0x15, 0x17, 0x2E, 0x37, 0x3F, 0x3F, 0x3F, 0x22, 0x21 },   0 },	
	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  WRCTRLD,  1, { 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
};
#endif

// Apollo rev0.2
static struct setting_table power_on_setting_table_smd[] = {
	{   POWCTL,  7, { 0x80, 0x00, 0x00, 0x0B, 0x33, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   VCMCTL,  5, { 0x6E, 0x6E, 0x7F, 0x7F, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SRCCTL,  5, { 0x12, 0x00, 0x03, 0xF0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
	{   MADCTL,  1, { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   COLMOD,  1, { 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  30 },	
	{   DISCTL, 11, { 0x14, 0x14, 0x03, 0x03, 0x04, 0x03, 0x04, 0x10, 0x04, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  GATECTL,  2, { 0x22, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  WRDISBV,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 }, //BRIGHTNESS	
	{ WRCABCMB,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  MIECTL1,  3, { 0x80, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   BCMODE,  1, { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL2,  3, { 0x20, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  MIECTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
//	{  MIECTL3,  2, { 0x2C, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{ RPGAMCTL, 15, { 0x00, 0x23, 0x15, 0x15, 0x1C, 0x19, 0x18, 0x1E, 0x24, 0x25, 0x25, 0x20, 0x10, 0x22, 0x21 },   0 },	
	{ RNGAMCTL, 15, { 0x19, 0x00, 0x15, 0x15, 0x1C, 0x1F, 0x1E, 0x24, 0x1E, 0x1F, 0x25, 0x20, 0x10, 0x22, 0x21 },   0 },	
	{ GPGAMCTL, 15, { 0x06, 0x23, 0x14, 0x14, 0x1D, 0x1A, 0x19, 0x1F, 0x24, 0x26, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
	{ GNGAMCTL, 15, { 0x19, 0x06, 0x14, 0x14, 0x1D, 0x20, 0x1F, 0x25, 0x1E, 0x20, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
	{ BPGAMCTL, 15, { 0x2C, 0x23, 0x20, 0x20, 0x23, 0x2F, 0x30, 0x39, 0x09, 0x09, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
	{ BNGAMCTL, 15, { 0x19, 0x2C, 0x20, 0x20, 0x23, 0x35, 0x36, 0x3F, 0x03, 0x03, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  WRCTRLD,  1, { 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   WRCABC,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
};

#if 1
// SONY WQVGA 3.2"
static struct setting_table power_on_setting_table_sony[] = {
	// Power Setting Sequence
	{   POWCTL,  8, { 0x80, 0x29, 0x29, 0x08, 0x33, 0x32, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   VCMCTL,  5, { 0x19, 0x19, 0x1E, 0x1E, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SRCCTL,  6, { 0x00, 0x00, 0x06, 0xF0, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
	// Initializing Sequence
	{     TEON,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   MADCTL,  1, { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   COLMOD,  1, { 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   DISCTL, 11, { 0x16, 0x16, 0x0F, 0x04, 0x04, 0x04, 0x04, 0x0A, 0x00, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  GATECTL,  2, { 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// Gamma Setting Sequence
	{ RPGAMCTL, 15, { 0x80, 0x00, 0x00, 0x00, 0x02, 0x1A, 0x22, 0x2C, 0x13, 0x10, 0x1A, 0x19, 0x0D, 0x84, 0x21 },   0 },	
	{ RNGAMCTL, 15, { 0x80, 0x00, 0x00, 0x00, 0x02, 0x1A, 0x22, 0x2C, 0x13, 0x10, 0x1A, 0x19, 0x0D, 0x84, 0x21 },   0 },	
//	{ GPGAMCTL, 15, { 0x06, 0x23, 0x14, 0x14, 0x1D, 0x1A, 0x19, 0x1F, 0x24, 0x26, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
//	{ GNGAMCTL, 15, { 0x19, 0x06, 0x14, 0x14, 0x1D, 0x20, 0x1F, 0x25, 0x1E, 0x20, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
//	{ BPGAMCTL, 15, { 0x2C, 0x23, 0x20, 0x20, 0x23, 0x2F, 0x30, 0x39, 0x09, 0x09, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
//	{ BNGAMCTL, 15, { 0x19, 0x2C, 0x20, 0x20, 0x23, 0x35, 0x36, 0x3F, 0x03, 0x03, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
	// RAM Address set
	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// RAM Data Write
	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// Manual Brightness Control
	{  MIECTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  WRDISBV,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 }, //BRIGHTNESS	
	{   BCMODE,  1, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	// Display On Sequence
	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
	{  WRCTRLD,  1, { 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },
};
#else
// SONY WQVGA 3.2" tuning
static struct setting_table power_on_setting_table_sony[] = {
	// Power Setting Sequence
	{   POWCTL,  7, { 0x80, 0x29, 0x29, 0x08, 0x33, 0x38, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   VCMCTL,  5, { 0x1F, 0x19, 0x20, 0x1E, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SRCCTL,  6, { 0x00, 0x00, 0x06, 0xF0, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{   SLPOUT,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
	// Initializing Sequence
	{     TEON,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   MADCTL,  1, { 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   COLMOD,  1, { 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{   DISCTL, 11, { 0x16, 0x16, 0x0F, 0x04, 0x04, 0x04, 0x04, 0x0A, 0x00, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    IFCTL,  4, { 0x00, 0x81, 0x30, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{  GATECTL,  2, { 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// Gamma Setting Sequence
	{ RPGAMCTL, 15, { 0x80, 0x00, 0x00, 0x00, 0x02, 0x1A, 0x22, 0x2C, 0x13, 0x10, 0x1A, 0x19, 0x0D, 0x84, 0x21 },   0 },	
	{ RNGAMCTL, 15, { 0x80, 0x00, 0x00, 0x00, 0x02, 0x1A, 0x22, 0x2C, 0x13, 0x10, 0x1A, 0x19, 0x0D, 0x84, 0x21 },   0 },	
//	{ GPGAMCTL, 15, { 0x06, 0x23, 0x14, 0x14, 0x1D, 0x1A, 0x19, 0x1F, 0x24, 0x26, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
//	{ GNGAMCTL, 15, { 0x19, 0x06, 0x14, 0x14, 0x1D, 0x20, 0x1F, 0x25, 0x1E, 0x20, 0x30, 0x1E, 0x1E, 0x22, 0x21 },   0 },	
//	{ BPGAMCTL, 15, { 0x2C, 0x23, 0x20, 0x20, 0x23, 0x2F, 0x30, 0x39, 0x09, 0x09, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
//	{ BNGAMCTL, 15, { 0x19, 0x2C, 0x20, 0x20, 0x23, 0x35, 0x36, 0x3F, 0x03, 0x03, 0x18, 0x13, 0x13, 0x22, 0x21 },   0 },	
	// RAM Address set
	{    CASET,  4, { 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	{    PASET,  4, { 0x00, 0x00, 0x01, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// RAM Data Write
	{    RAMWR,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },	
	// Manual Brightness Control
	{  MIECTL3,  2, { 0x7C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	{  WRDISBV,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 }, //BRIGHTNESS	
	{   BCMODE,  1, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
	// Display On Sequence
	{   DISPON,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  50 },	
	{  WRCTRLD,  1, { 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	0 },	
};
#endif

#define POWER_ON_SETTINGS(x)	(int)(sizeof(x)/sizeof(struct setting_table))

static struct setting_table power_off_setting_table[] = {
	{  WRCTRLD,  1, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 },
	{  DISPOFF,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },  40 },
	{    SLPIN,  0, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 120 },
};

#define POWER_OFF_SETTINGS	(int)(sizeof(power_off_setting_table)/sizeof(struct setting_table))

static struct setting_table backlight_setting_table = 
	{ WRDISBV,  1, { 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   0 };

static u8 mtp_value_smd[3] = { 0x52, 0x09, 0x11 };
static u8 mtp_value_sony[3] = { 0x52, 0x2C, 0x11 };

static int lcd_type = 0;
enum {
	LcdTypeNone = -1,
	LcdTypeSMD = 1,
	LcdTypeSony = 2,
};

#if 1
static void read_ldi_register(u8 addr, u8 *buf, int count)
{
	long i, j;

	LCD_CSX_HIGH
	udelay(DEFAULT_USLEEP);
	LCD_SCL_HIGH 
	udelay(DEFAULT_USLEEP);

	/* Write Command */
	LCD_CSX_LOW
	udelay(DEFAULT_USLEEP);
	LCD_SCL_LOW 
	udelay(DEFAULT_USLEEP);		
	LCD_SDI_LOW 
	udelay(DEFAULT_USLEEP);
	
	LCD_SCL_HIGH 
	udelay(DEFAULT_USLEEP); 

   	for (i = 7; i >= 0; i--) { 
		LCD_SCL_LOW
		udelay(DEFAULT_USLEEP);
		if ((addr >> i) & 0x1)
			LCD_SDI_HIGH
		else
			LCD_SDI_LOW
		udelay(DEFAULT_USLEEP);	
		LCD_SCL_HIGH
		udelay(DEFAULT_USLEEP);	
	}

	//swith input
//	LCD_SDI_SWITCH_INPUT

	if(count>1)
		{
		//dummy clock cycle
		LCD_SCL_LOW
		udelay(DEFAULT_USLEEP); 	
		LCD_SCL_HIGH
		udelay(DEFAULT_USLEEP);	
		}

	/* Read Parameter */
	if (count > 0) {
	for (j = 0; j < count; j++) {

		for (i = 7; i >= 0; i--) { 
			LCD_SCL_LOW
			udelay(DEFAULT_USLEEP);	
			// read bit
			if(LCD_SDO_DATA)
				buf[j] |= (0x1<<i);
			else
				buf[j] &= ~(0x1<<i);
			LCD_SCL_HIGH
			udelay(DEFAULT_USLEEP);	
		}

	}
	}

	LCD_CSX_HIGH
	udelay(DEFAULT_USLEEP);	

	//switch output
//	LCD_SDI_SWITCH_OUTPUT_LOW
	
}
#endif

static void setting_table_write(struct setting_table *table)
{
	s32 i, j;

	LCD_CSX_HIGH
	udelay(DEFAULT_USLEEP);
	LCD_SCL_HIGH 
	udelay(DEFAULT_USLEEP);

	/* Write Command */
	LCD_CSX_LOW
	udelay(DEFAULT_USLEEP);
	LCD_SCL_LOW 
	udelay(DEFAULT_USLEEP);		
	LCD_SDI_LOW 
	udelay(DEFAULT_USLEEP);
	
	LCD_SCL_HIGH 
	udelay(DEFAULT_USLEEP); 

   	for (i = 7; i >= 0; i--) { 
		LCD_SCL_LOW
		udelay(DEFAULT_USLEEP);
		if ((table->command >> i) & 0x1)
			LCD_SDI_HIGH
		else
			LCD_SDI_LOW
		udelay(DEFAULT_USLEEP);	
		LCD_SCL_HIGH
		udelay(DEFAULT_USLEEP);	
	}

	LCD_CSX_HIGH
	udelay(DEFAULT_USLEEP);	

	/* Write Parameter */
	if ((table->parameters) > 0) {
	for (j = 0; j < table->parameters; j++) {
		LCD_CSX_LOW 
		udelay(DEFAULT_USLEEP); 	
		
		LCD_SCL_LOW 
		udelay(DEFAULT_USLEEP); 	
		LCD_SDI_HIGH 
		udelay(DEFAULT_USLEEP);
		LCD_SCL_HIGH 
		udelay(DEFAULT_USLEEP); 	

		for (i = 7; i >= 0; i--) { 
			LCD_SCL_LOW
			udelay(DEFAULT_USLEEP);	
			if ((table->parameter[j] >> i) & 0x1)
				LCD_SDI_HIGH
			else
				LCD_SDI_LOW
			udelay(DEFAULT_USLEEP);	
			LCD_SCL_HIGH
			udelay(DEFAULT_USLEEP);					
		}

			LCD_CSX_HIGH
			udelay(DEFAULT_USLEEP);	
	}
	}

	if(table->wait)
		msleep(table->wait);
	else
		udelay(DEFAULT_USLEEP*10);

}



static void determine_lcd_type(void)
{
	u8 data[4];

	// read MTP from LDI
	read_ldi_register(RDDIDIF, &data[0], 3);
	printk("ldi mtpdata: %x %x %x\n", data[0], data[1], data[2]);

	if(data[0]==mtp_value_smd[0] && data[1]==mtp_value_smd[1] && data[2]==mtp_value_smd[2])
		{
		printk(KERN_NOTICE "lcd type is smd\n");
		lcd_type = LcdTypeSMD;
		}
	else if(data[0]==mtp_value_sony[0] && data[1]==mtp_value_sony[1] && data[2]==mtp_value_sony[2])
		{
		printk(KERN_NOTICE "lcd type is sony\n");
		lcd_type = LcdTypeSony;
		}
	else if(data[0] == 0xff)
		{
		printk(KERN_WARNING "lcd type is none(lcd may be absent)\n");
		lcd_type = LcdTypeNone;
		}
	else
		{
		printk(KERN_NOTICE "default lcd type is smd\n");
		lcd_type = LcdTypeSMD;
		}

}


/*
 *	LCD Power Handler
 */

void lcd_power_ctrl(s32 value)
{
	s32 i;	
	u8 data;
	u8 mtpdata[4];

	
	if (value) 
		{

		if(!lcd_pm_state)
			{
			printk("s3cfb force resume!\n");
			s3cfb_force_resume();
			}
	
		/* Power On Sequence */
#ifdef USE_GPIO_ENABLE_FOR_LCD_POWER
//	gpio_set_value(GPIO_MLCD_ON, GPIO_LEVEL_HIGH);
#else
		if(TRUE != Set_MAX8998_PM_REG(ELDO12, 1) )			// VLCD 1.8V
			{
			printk("%s, error: LDO12 turn on\n", __func__);
			}
		if(TRUE != Set_MAX8998_PM_REG(ELDO11, 1) )			// VLCD 3.0V
			{
			printk("%s, error: LDO11 turn on\n", __func__);
			}
#endif	//USE_GPIO_ENABLE_FOR_LCD_POWER
		msleep(10);	

		/* Reset Deasseert */
		gpio_set_value(GPIO_MLCD_RST, GPIO_LEVEL_HIGH);
		msleep(10);	
	
		/* Reset Asseert */
		gpio_set_value(GPIO_MLCD_RST, GPIO_LEVEL_LOW);
		msleep(10);	

		/* Reset Deasseert */
		gpio_set_value(GPIO_MLCD_RST, GPIO_LEVEL_HIGH);
		msleep(20);

	#if 1
		determine_lcd_type();
	#endif

#if (CONFIG_BOARD_REVISION == CONFIG_APOLLO_EMUL)
		if(apollo_get_saved_lcd_id_value())
			for (i = 0; i < POWER_ON_SETTINGS(power_on_setting_table_32); i++)
				setting_table_write(&power_on_setting_table_32[i]);			// new lcd
		else
			for (i = 0; i < POWER_ON_SETTINGS(power_on_setting_table_30); i++)
				setting_table_write(&power_on_setting_table_30[i]);			// old lcd
#else
		if(lcd_type == LcdTypeSony)
			{
			for (i = 0; i < POWER_ON_SETTINGS(power_on_setting_table_sony); i++)
				setting_table_write(&power_on_setting_table_sony[i]);	
			}
		else
			{
			for (i = 0; i < POWER_ON_SETTINGS(power_on_setting_table_smd); i++)
				setting_table_write(&power_on_setting_table_smd[i]);	
			}
#endif

		// brightness setting
		printk("%s brightness:0x%x\n", __func__, backlight_level);
		s6d04d1_set_brightness((int)(backlight_level));			// 1~255
		//s6d04d1_set_brightness((int)((backlight_level * 3)/4));	// 1~127 => 1~100	

	}
	else {

		/* Power Off Sequence */
	
		for (i = 0; i < POWER_OFF_SETTINGS; i++)
			setting_table_write(&power_off_setting_table[i]);	

		/* Reset Assert */
		gpio_set_value(GPIO_MLCD_RST, GPIO_LEVEL_LOW);		

#ifdef USE_GPIO_ENABLE_FOR_LCD_POWER
//		gpio_set_value(GPIO_MLCD_ON, GPIO_LEVEL_LOW);
#else
		if(TRUE != Set_MAX8998_PM_REG(ELDO11, 0) )			// VLCD 3.0V
			{
			printk("%s, error: LDO11 turn off\n", __func__);
			}
		if(TRUE != Set_MAX8998_PM_REG(ELDO12, 0) )			// VLCD 1.8V
			{
			printk("%s, error: LDO12 turn off\n", __func__);
			}
#endif	//USE_GPIO_ENABLE_FOR_LCD_POWER

		
	}

	lcd_power = value;
}

#define MAX_BRIGHTNESS_LEVEL 0xFF
#define LOW_BRIGHTNESS_LEVEL 0x1E

#define MAX_BACKLIGHT_VALUE_SMD 0x9B
#define LOW_BACKLIGHT_VALUE_SMD 0x1F
#define DIM_BACKLIGHT_VALUE_SMD 0x12

#define MAX_BACKLIGHT_VALUE_SONY 0x9B //0xB4
#define LOW_BACKLIGHT_VALUE_SONY 0x1F
#define DIM_BACKLIGHT_VALUE_SONY 0x12

static int s6d04d1_backlight_on(void)
{
		return 0;
}

static int s6d04d1_backlight_off(void)
{
		return 0;
}

static int s6d04d1_get_tune(int level)
{
	int tune_value;

	if(lcd_type == 0)
		{
		determine_lcd_type();
		}

	if(lcd_type == LcdTypeSony)
		{
		//SONY_LCD
		if(level > MAX_BRIGHTNESS_LEVEL)
			level = MAX_BRIGHTNESS_LEVEL;

		if(level >= LOW_BRIGHTNESS_LEVEL)
			tune_value = (level - LOW_BRIGHTNESS_LEVEL) * (MAX_BACKLIGHT_VALUE_SONY-LOW_BACKLIGHT_VALUE_SONY) / (MAX_BRIGHTNESS_LEVEL-LOW_BRIGHTNESS_LEVEL) + LOW_BACKLIGHT_VALUE_SONY;
		else if(level > 0)
			tune_value = DIM_BACKLIGHT_VALUE_SONY;
		else
			tune_value = level;
		
		if(tune_value > MAX_BACKLIGHT_VALUE_SONY)
			tune_value = MAX_BACKLIGHT_VALUE_SONY;			// led_val must be less than or equal to MAX_BACKLIGHT_VALUE

		if(level && !tune_value)
			tune_value = 1;
		}
	else
		{
		// SMD LCD
		if(level > MAX_BRIGHTNESS_LEVEL)
			level = MAX_BRIGHTNESS_LEVEL;

		if(level >= LOW_BRIGHTNESS_LEVEL)
			tune_value = (level - LOW_BRIGHTNESS_LEVEL) * (MAX_BACKLIGHT_VALUE_SMD-LOW_BACKLIGHT_VALUE_SMD) / (MAX_BRIGHTNESS_LEVEL-LOW_BRIGHTNESS_LEVEL) + LOW_BACKLIGHT_VALUE_SMD;
		else if(level > 0)
			tune_value = DIM_BACKLIGHT_VALUE_SMD;
		else
			tune_value = level;
		
		if(tune_value > MAX_BACKLIGHT_VALUE_SMD)
			tune_value = MAX_BACKLIGHT_VALUE_SMD;			// led_val must be less than or equal to MAX_BACKLIGHT_VALUE

		if(level && !tune_value)
			tune_value = 1;
		}

	return tune_value;
}

static int s6d04d1_set_brightness(int level)
{
	unsigned int led_val;

	led_val = s6d04d1_get_tune(level);

/*
	if(level > MAX_BRIGHTNESS_LEVEL)
		level = MAX_BRIGHTNESS_LEVEL;

	if(level >= LOW_BRIGHTNESS_LEVEL)
		led_val = (level - LOW_BRIGHTNESS_LEVEL) * (MAX_BACKLIGHT_VALUE-LOW_BACKLIGHT_VALUE) / (MAX_BRIGHTNESS_LEVEL-LOW_BRIGHTNESS_LEVEL) + LOW_BACKLIGHT_VALUE;
	else if(level > 0)
		led_val = DIM_BACKLIGHT_VALUE;
	else
		led_val = level;
	
	//led_val = (USE_BRIGHTNESS_LEVEL * level) / MAX_BRIGHTNESS_LEVEL;

	if(led_val > MAX_BACKLIGHT_VALUE)
		led_val = MAX_BACKLIGHT_VALUE;			//	led_val must be less than or equal to MAX_BACKLIGHT_VALUE

	if(level && !led_val)
		led_val = 1;
*/

	backlight_setting_table.parameter[0] = led_val;

	//printk("%s brightness:0x%x\n", __func__, backlight_setting_table.parameter[0]);
	setting_table_write(&backlight_setting_table);	

	return 0;
}

static int __init s6d04d1_init(void)
{  

    printk("#####################  %s : START ##################\n",__FUNCTION__);
#ifdef USE_GPIO_ENABLE_FOR_LCD_POWER
//	gpio_set_value(GPIO_MLCD_ON, GPIO_LEVEL_HIGH);
#else
	if(TRUE != Set_MAX8998_PM_REG(ELDO12, 1) )			// VLCD 1.8V
		{
		printk("%s, error: LDO12 turn on\n", __func__);
		}
	if(TRUE != Set_MAX8998_PM_REG(ELDO11, 1) )			// VLCD 3.0V
		{
		printk("%s, error: LDO11 turn on\n", __func__);
		}
#endif	//USE_GPIO_ENABLE_FOR_LCD_POWER
	msleep(10);

	backlight_power = ON; 
	//LCD power on      
	lcd_power_ctrl(1);

	return 0;
}

void s3cfb_set_lcd_power(int value)
{
	printk("#####%s: value %d \n", __FUNCTION__, value);
        lcd_power_ctrl(value);
}
EXPORT_SYMBOL(s3cfb_set_lcd_power);

int s3cfb_get_lcd_power(void)
{
  return lcd_power;
}

EXPORT_SYMBOL(s3cfb_get_lcd_power);

extern void s3c_bat_set_compensation_for_drv(int mode, int offset);
#define OFFSET_LCD_ON			(0x1 << 7)

void s3cfb_set_backlight_power(int value)
{
	printk("#####%s: value %d \n", __FUNCTION__, value); 
	if ((value < OFF) ||    /* Invalid Value */
		(value > ON) ||
		(value == backlight_power))     /* Same Value */
		return;
	
	if(value == ON)
		{
		if (lcd_power == OFF)
			{
			lcd_power_ctrl(ON);
			}
		s6d04d1_backlight_on();
		s3c_bat_set_compensation_for_drv(1, OFFSET_LCD_ON);
		}
	else
		{
		s6d04d1_backlight_off();
		lcd_power_ctrl(OFF);
		s3c_bat_set_compensation_for_drv(0, OFFSET_LCD_ON);
		}

	backlight_power = value;
}
EXPORT_SYMBOL(s3cfb_set_backlight_power);

int s3cfb_get_backlight_power(void)
{
	return backlight_power;
}
EXPORT_SYMBOL(s3cfb_get_backlight_power);

void s3cfb_set_backlight_level(int value)
{
	//printk("#####%s: value %d \n", __FUNCTION__, value);
	if (value == backlight_level)     /* Same Value */
		return;

	if (backlight_power)
		s6d04d1_set_brightness(value);		// 1~255
		//s6d04d1_set_brightness((int)((value * 3)/4));

	backlight_level = value;
}
EXPORT_SYMBOL(s3cfb_set_backlight_level);

int s3cfb_get_backlight_level(void)
{
	return backlight_level;
}
EXPORT_SYMBOL(s3cfb_get_backlight_level);

#define S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS	255

static s32 s6d04d1_backlight_brightness = S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS;
static DEFINE_MUTEX(s6d04d1_backlight_lock);

static void s6d04d1_set_backlight_level(int value)
{
	//printk("#####%s: value %d \n", __FUNCTION__, value);
	printk(KERN_INFO "#####%s: value %d \n", __FUNCTION__, value);
	if (value == backlight_level)     /* Same Value */
		return;

	if(value)
		{
		if(!backlight_power)
			{
			s3cfb_set_backlight_power(ON);
			}
		}
	else
		{
		if(backlight_power)
			{
			s3cfb_set_backlight_power(OFF);
			}
		}

	printk ( "@@@@@     %s : value %d\n", __func__, value );
	s6d04d1_set_brightness(value);		// 1~255
	//s6d04d1_set_brightness((int)((value * 3)/4));		// 1~127 => 1~100

	backlight_level = value;
}

static void s6d04d1_brightness_set(struct led_classdev *led_cdev, enum led_brightness value)
{
	mutex_lock(&s6d04d1_backlight_lock);
	s6d04d1_set_backlight_level(value);		// 1~255
	mutex_unlock(&s6d04d1_backlight_lock);
}

static struct led_classdev s6d04d1_backlight_led  = {
	.name		= "lcd-backlight",
	.brightness = S6D04D1_DEFAULT_BACKLIGHT_BRIGHTNESS,
	.brightness_set = s6d04d1_brightness_set,
};

static int s6d04d1_backlight_probe(struct platform_device *pdev)
{
    int ret;

	ret = led_classdev_register(&pdev->dev, &s6d04d1_backlight_led);
	if (ret < 0)
		printk("%s fail: led_classdev_register\n", __func__);
		
	return 0;
}

static int s6d04d1_backlight_remove(struct platform_device *pdev)
{
	led_classdev_unregister(&s6d04d1_backlight_led);
	return 0;
}

static struct platform_driver s6d04d1_backlight_driver = {
	.probe		= s6d04d1_backlight_probe,
	.remove		= s6d04d1_backlight_remove,
	.driver		= {
		.name		= "s6d04d1-backlight",
		.owner		= THIS_MODULE,
	},
};

static int __init s6d04d1_backlight_init(void)
{
	return platform_driver_register(&s6d04d1_backlight_driver);
}

static void __exit s6d04d1_backlight_exit(void)
{
	platform_driver_unregister(&s6d04d1_backlight_driver);
}
module_init(s6d04d1_backlight_init);
module_exit(s6d04d1_backlight_exit);

#ifdef CONFIG_FB_S3C_LCD_INIT
//SEC: sm.kim 20091210 remove init call; bootloader turn on lcd
//late_initcall(s6d04d1_init);
#endif
//module_init(lms300_init);
//module_exit(lms300_exit);

#if 1
#define LOGO_MEM_BASE		(0x40000000 + 0x05000000 - 0x100000)	/* ONEDRAM_BASE + ONEDRAM_SIZE(80MB) - 1MB */
#define LOGO_MEM_SIZE		(S3C_FB_HRES * S3C_FB_VRES * 2)

void s3cfb_display_logo(struct fb_info *fbinfo)
{
	// (100311 / kcoolsw ) support 24bpp & optimization
	/*
	u8 *logo_virt_buf;
	logo_virt_buf = ioremap_nocache(LOGO_MEM_BASE, LOGO_MEM_SIZE);
	memcpy(fbinfo->screen_base, logo_virt_buf, LOGO_MEM_SIZE);	
	iounmap(logo_virt_buf);
	*/
	/*struct rgb565
	{
		u16 red:5;
		u16 green:6;
		u16 blue:5;
	} rgb565_data;

	struct rgb888{
		u8 red;
		u8 green;
		u8 blue;
		u8 alpha;
	} rgb888_data;

	u8 *logo_virt_buf;
	int i;
	u16 *src;
	u32 *dst;

	logo_virt_buf = ioremap_nocache(LOGO_MEM_BASE, LOGO_MEM_SIZE);

	switch(fbinfo->var.bits_per_pixel)
	{
		case 24 :
		case 32 :
			src = (u16 *)logo_virt_buf;
			dst = (u32 *)fbinfo->screen_base;

			for(i = 0; i < LOGO_MEM_SIZE; i += 2, src++, dst++)
			{
				((struct rgb888*)dst)->red   = ((struct rgb565*)src)->red  << 3;
				((struct rgb888*)dst)->green = ((struct rgb565*)src)->green<< 2;
				((struct rgb888*)dst)->blue  = ((struct rgb565*)src)->blue << 3;
			}
			break;

		case 16 :
		default:
			// 16bpp
			memcpy(fbinfo->screen_base, logo_virt_buf, LOGO_MEM_SIZE); 
			break;
	}

	iounmap(logo_virt_buf);
*/
}


#include "s3cfb_progress.h"

#define PROGRESS_WIN_NUM	1

static int progress = 0;

static int progress_flag = ON;

static struct timer_list progress_timer;

static struct s3cfb_global *fb_ctrl = NULL;

static int (*allocfb)(struct fb_info *) = NULL;
static int (*releasefb)(struct fb_info *) = NULL;

static void progress_timer_handler(unsigned long data)
{
#if 1
	struct fb_info *fbinfo;
	unsigned short *bar_src, *bar_dst;	
	int	i, j, p;

	if(!fb_ctrl)
		return;
	fbinfo = fb_ctrl->fb[PROGRESS_WIN_NUM];
		
	/* 1 * 8 R5G5B5 BMP (Aligned 4 Bytes) */
	bar_dst = (unsigned short *)(fbinfo->screen_base + (((240 * 347) + 31) * 2));
	bar_src = (unsigned short *)(progress_bar + sizeof(progress_bar) - 4);

	for (i = 0; i < 8; i++) {
		for (j = 0; j < 2; j++) {
			p = ((240 * i) + (progress * 2) + j);
			*(bar_dst + p) = (*(bar_src - (i * 2)) | 0x8000);
		}
	}	

	progress++;

	if (progress > 88) {
		del_timer(&progress_timer);
	}
	else {
		progress_timer.expires = (get_jiffies_64() + data); 
		progress_timer.function = progress_timer_handler; 
		add_timer(&progress_timer);
	}
#endif
}

void s3cfb_restart_progress()
{
#if 1
	struct fb_info *fbinfo;
	unsigned short *bg_src, *bg_dst;	
	unsigned short *bar_src, *bar_dst;	
	int	i, j, p;

	if (progress_flag == OFF)
		return;
	
	if(!fb_ctrl)
		return;
	fbinfo = fb_ctrl->fb[PROGRESS_WIN_NUM];
	
	del_timer(&progress_timer);

	/* 240 * 19 R5G5B5 BMP */
	bg_dst = (unsigned short *)(fbinfo->screen_base + ((240 * 342) * 2));
	bg_src = (unsigned short *)(progress_bg + sizeof(progress_bg) - 2);

	for (i = 0; i < 19; i++) {
		for (j = 0; j < 240; j++) {
			p = ((240 * i) + j);
			if ((*(bg_src - p) & 0x7FFF) == 0x0000)
				*(bg_dst + p) = (*(bg_src - p) & ~0x8000);
			else
				*(bg_dst + p) = (*(bg_src - p) | 0x8000);
		}
	}

	progress = 0;

	progress_timer.expires = (get_jiffies_64() + (HZ/1)); 
	progress_timer.function = progress_timer_handler; 
	progress_timer.data = (HZ/3);
	add_timer(&progress_timer);
#endif
}
EXPORT_SYMBOL(s3cfb_restart_progress);

static unsigned int new_wincon1; 
static unsigned int old_wincon1; 
static unsigned int new_vidosd1c; 
static unsigned int old_vidosd1c; 

void s3cfb_start_progress(struct s3cfb_global* ctrl, int (*func_allocfb)(struct fb_info *), int (*func_releasefb)(struct fb_info *))
{
#if 1
	struct fb_info *fbinfo = ctrl->fb[PROGRESS_WIN_NUM];
	unsigned short *bg_src, *bg_dst;	
	unsigned int data;
	int	i, j, p;

	// save arguments //
	fb_ctrl = ctrl;
	allocfb = func_allocfb;
	releasefb =func_releasefb;

	func_allocfb(fbinfo);
	memset(fbinfo->screen_base, 0x00, LOGO_MEM_SIZE);	

	/* 240 * 19 R5G5B5 BMP */
	bg_dst = (unsigned short *)(fbinfo->screen_base + ((240 * 342) * 2));
	bg_src = (unsigned short *)(progress_bg + sizeof(progress_bg) - 2);

	for (i = 0; i < 19; i++) {
		for (j = 0; j < 240; j++) {
			p = ((240 * i) + j);
			if ((*(bg_src - p) & 0x7FFF) == 0x0000)
				*(bg_dst + p) = (*(bg_src - p) & ~0x8000);
			else
				*(bg_dst + p) = (*(bg_src - p) | 0x8000);
		}
	}

	old_wincon1  = readl(ctrl->regs + S3C_WINCON(PROGRESS_WIN_NUM));
	old_vidosd1c = readl(ctrl->regs + S3C_VIDOSD_C(PROGRESS_WIN_NUM));

	new_wincon1 = S3C_WINCON_DATAPATH_DMA | S3C_WINCON_BUFSEL_0 | S3C_WINCON_BUFAUTO_DISABLE | \
	              S3C_WINCON_BITSWP_DISABLE | S3C_WINCON_BYTESWP_DISABLE | S3C_WINCON_HAWSWP_ENABLE | \
	              S3C_WINCON_BURSTLEN_16WORD | S3C_WINCON_BLD_PIXEL | S3C_WINCON_BPPMODE_16BPP_A555 | \
	              S3C_WINCON_ALPHA0_SEL | S3C_WINCON_ENWIN_ENABLE ;
	
	new_vidosd1c = S3C_VIDOSD_ALPHA1_R(0xF)|S3C_VIDOSD_ALPHA1_G(0xF)|S3C_VIDOSD_ALPHA1_B(0xF);

	data = readl(ctrl->regs + S3C_WINSHMAP);
	data |= (1<<PROGRESS_WIN_NUM);
	writel(data, ctrl->regs + S3C_WINSHMAP);
	
	writel(new_vidosd1c, ctrl->regs + S3C_VIDOSD_C(PROGRESS_WIN_NUM));
	writel(new_wincon1, ctrl->regs + S3C_WINCON(PROGRESS_WIN_NUM));

	init_timer(&progress_timer);
	progress_timer.expires = (get_jiffies_64() + (HZ/10)); 
	progress_timer.function = progress_timer_handler; 
	progress_timer.data = (HZ/15);
	add_timer(&progress_timer);

	progress_flag = ON;
#endif
}


void s3cfb_stop_progress(void)
{
#if 1
	if (progress_flag == OFF)
		return;

	del_timer(&progress_timer);

	if(fb_ctrl)
	{
		writel(old_wincon1, fb_ctrl->regs + S3C_WINCON(PROGRESS_WIN_NUM));
		writel(old_vidosd1c, fb_ctrl->regs + S3C_VIDOSD_C(PROGRESS_WIN_NUM));
	}
		
	if(releasefb)
		releasefb(fb_ctrl->fb[PROGRESS_WIN_NUM]);
	
	progress_flag = OFF;
#endif
}
#endif
